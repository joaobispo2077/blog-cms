{
  "data": {
    "setting": null,
    "posts": [
      {
        "id": "611526a10eec2e8db81cea44",
        "slug": "programacao-funcional-com-java-script-higher-order-e-first-class-functions",
        "title": "Programação Funcional com JavaScript: Higher-Order e First-Class functions",
        "excerpt": "Existem 2 recursos que estão presentes no JavaScript que abrem um mar de possibilidades para a escrita de um código mais funcional.",
        "content": "<p>Existem 2 recursos que estão presentes no JavaScript que abrem um mar de possibilidades para a escrita de um código mais funcional, esses recursos são as funções de alta ordem (Higher-Order functions) e as funções de primeira linha (First-Class functions ou First-Class Citizens).</p><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/1200/1*uVwhsCEquQHmxm1shQQNDg.png\"></figure><p>Pixel art que eu fiz no que eu penso quando ouço “Função de Primeira Linha/Alta ordem”</p><hr><h3>Higher-order functions</h3><p>Função de alta ordem define uma função que tem a capacidade de poder manipular outras funções, seja podendo receber funções como argumento e/ou podendo retornar outras funções.</p><p>Um caso em que podemos aplicar isso rapidamente, como exemplo, seria se tivéssemos várias funções que executam cálculos e quiséssemos interceptar algo que ocorra antes ou depois de todos cálculos e para isso podemos transferir a responsabilidade de executar o cálculo para uma outra função, sendo essa última uma Higher-order function.&nbsp;</p><h4>Função que recebe outra função como argumento</h4><p>Começarei escrevendo uma função que faz a soma de infinitos números:</p><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/900/1*B7f3_ef7Sn5nwn4FTZiqaA.png\" alt=\"function sum(…numbers) {\n&nbsp;return numbers.reduce((a, b) => a + b);\n&nbsp;}\"></figure><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/1200/1*iMyUJCEXTPCblYPnWWhakw.png\" alt=\"function sum(…numbers: number[]): number {\n&nbsp;return numbers.reduce((a, b) => a + b);\n&nbsp;}\"></figure><p>Função que recebe uma quantidade indefinida de números e retorna a soma de todos os números que&nbsp;receber.</p><p>Utilizarei exemplos tanto em Javascript quanto em Typescript para o incentivo do uso de tipagem estática. Ainda sim, o princípio dessa função de somar, continua sendo o mesmo, seja com sua tipagem dinâmica ou estática. Mesmo que com a inferência de tipos, o <strong>Typescript consiga deduzir grande parte dos tipos</strong> do exemplo, mas <strong>para fins didáticos explicitarei a maioria dos tipos</strong>. Também, disponibilizarei o arquivo dos códigos ao final do artigo.</p><p>Basicamente no código acima, com o uso do <a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Functions/rest_parameters\">REST Operator</a> (três pontos), a função consegue armazenar em uma variável de lista (Array) um número indefinido de argumentos. A seguir, com o uso do <a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\">método reduce</a> percorremos essa lista derivada dos argumentos recebidos e somamos todos elementos da lista.</p><p>Note que a diferença para Typescript é que com o uso da sintaxe de <a href=\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html\">Type annotations</a> torno explicito que o resultado da aglutinação dos argumentos em uma lista deve ser uma lista de números (number) e que o resultado da soma de todos números é um valor de tipo numérico (number).</p><p>Após isso, podemos fazer a função que executará o cálculo, que será a Higher-order function:</p><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/900/1*OcxSeMfzZxl0XxKFc3L-PQ.png\" alt=\"function calculate(fn,&nbsp;…numbers) {\n&nbsp;console.log(‘received numbers: ‘, numbers);\n&nbsp;return fn(…numbers);\n&nbsp;}\"></figure><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/1200/1*_Q-6N26At4-_UJsnFNsH4w.png\" alt=\"type CalculationsMapper = (…numbers: number[]) => number;\n&nbsp;\n&nbsp;function calculate(fn: CalculationsMapper,&nbsp;…numbers: number[]): number {\n&nbsp;console.log(‘received numbers: ‘, numbers);\n&nbsp;return fn(…numbers);\n&nbsp;}\"></figure><p>Função que recebe uma outra função e quantidade indefinida de números e retorna o resultado da execução da função recebida, tendo sido invocada com a quantidade indefinida de&nbsp;números.</p><p>Perceba, que essa <strong>função “calculate” consegue receber outra função como argumento</strong>, logo essa <strong>é uma função de alta ordem (higher-order function)</strong>, ela também recebe uma quantidade indefinida de números como argumento, para que, então intercepta os números recebidos e execute essa função que foi recebida com a quantidade indefinida de argumentos. Essa prática de uma função receber outra função e executar, <strong>também é conhecida como</strong> <strong>function callback</strong>, mas também é possível encontrar isso sendo referenciado somente como “<a href=\"https://developer.mozilla.org/pt-BR/docs/Glossary/Callback_function\">Callback</a>”.</p><p>No Typescript, ocorre que declarei um <a href=\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases\">Type Alias</a> que chamei de mapeador de cálculos (Calculations Mapper) para a assinatura de uma função que recebe indefinidos números e retorna um número como resultado de sua execução. E em seguida, coloco que a “fn” que a função recebe terá assinatura de mapeador de cálculos citada, por fim torno explícito que a quantidade indefinida de argumentos será aglutinada em uma lista de números e o resultado será do tipo numérico. É notável que o código ficou mais verboso, entretanto também mais descritivo e documentado, pois com Javascript não é evidente que o parâmetro “fn” deva ser passado com um argumento de função, muito menos que tipo de função.</p><p>Agora, basta executar a função que você verá que funciona com mínimos argumentos e também com muitos:</p><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/900/1*pi65jEmB0wDoA3ZUFxoCfA.png\" alt=\"const firstResult = calculate(sum, 2, 2);\n&nbsp;console.log(firstResult); // output: 4\"></figure><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/1200/1*krjC82z45OD9if5H9BiL8w.png\" alt=\"const secondResult = calculate(sum, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n&nbsp;console.log(secondResult); // output: 45\"></figure><p>Duas invocações da função calculate, passando a função sum como primeiro argumento e números 2 e 2 na primeira execução e tendo como resultado 4 e na segunda execução passando a função sum como primeiro argumento e como demais argumentos os números: 1, 2, 3, 4, 5, 6, 7, 8 e 9, e tendo como resultado 45.</p><p>Com essas invocações e resultados, concluo que esse experimento de uma função receber outra função como argumento elucida bem ideia de uma função de alta ordem.</p><h4>Função que retorna outra&nbsp;função</h4><p>Modificarei a estrutura já feita para que haja uma função que retorne outra função como resultado de sua execução.</p><p>Para isso, na função calculate, invés de passar a função que será executada como primeiro argumento, passarei um texto com o símbolo da operação que gostaria que fosse executada, e a função calculate, utilizará outra função chamada “getCalculateOperationBySymbol” que receberá o símbolo recebido e retornará a função da operação relacionada ao símbolo recebido.</p><p>Antes disso, criarei uma função que subtraí indefinidos argumentos que será bastante semelhante a função de soma:</p><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/900/1*CIQl2Y_0jw0K2QBlNOOHAw.png\" alt=\"function subtract(…numbers) {\n&nbsp;return numbers.reduce((a, b) => a — b);\n&nbsp;}\"></figure><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/1200/1*4Ae1u1-feQ0gLEiHHqUxSA.png\" alt=\"function subtract(…numbers: number[]): number {\n&nbsp;return numbers.reduce((a, b) => a — b);\n&nbsp;}\"></figure><p>Função que recebe uma quantidade indefinida de números e retorna a subtração de todos os números que&nbsp;receber.</p><p>Veja que essa função chamada de “subtract”, é idêntica a função “sum”, exceto pelo motivo de que há o sinal de subtração entre <i>a</i> e <i>b, </i>no caso “<i>b”</i> seria o número atual, e “<i>a”</i> seria o resultado da última subtração retornando pela subtração de “a” menos “b”.</p><p>Agora, vou construir a função “getCalculateOperationBySymbol”:</p><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/900/1*pD19qxdstTziKZN8JHqqrw.png\" alt=\"function getCalculateOperationBySymbol(symbol) {\n&nbsp;const operations = {\n&nbsp;‘+’: sum,\n&nbsp;‘-’: subtract,\n&nbsp;}\n&nbsp;\n&nbsp;return operations[symbol];\n&nbsp;}\"></figure><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/1200/1*06fdes8hWfnTO3Za4B8kgA.png\" alt=\"type OperationSymbols = ‘+’ | ‘-’;\n&nbsp;\n&nbsp;function getCalculateOperationBySymbol(symbol: OperationSymbols): CalculationsMapper {\n&nbsp;const operations: Record<OperationSymbols, CalculationsMapper> = {\n&nbsp;‘+’: sum,\n&nbsp;‘-’: subtract,\n&nbsp;}\n&nbsp;\n&nbsp;return operations[symbol];\n&nbsp;}\"></figure><p>Função que recebe um símbolo como argumento e retorna a operação aritmética referente ao símbolo recebido.</p><p>Nessa função, que recebe o texto do símbolo da operação contém um objeto chamada “operations” (estrutura de chave-valor), onde as chaves são as operações e os valores são as funções referentes ao símbolo da operação. E então, ao usar sintaxe de “operations[symbol]” estou acessando um valor que é a referência da função selecionada e é retornada essa referência de função, ou seja temos outra Higher-order-function, entretanto sendo tipo que retorna uma função diferentemente da anterior.</p><p>No Typescript, declarei um Type Alias chamado “<i>OperationSymbols</i>” que usa de <a href=\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types\">Union Types</a> usando valores como tipos, que basicamente é uma estrutura pode definir que uma variável somente poderá possuir os valores “+” ou “-” e inclusive atribuo esse tipo para o argumento symbol da função “getCalculateOperationBySymbol”. Também explicito que o retorno da função será uma função da assinatura “<i>CalculationsMapper” </i>que vimos anteriormente e coloco a tipagem de Record que é um <a href=\"https://www.typescriptlang.org/docs/handbook/2/generics.html\">tipo genérico</a> para dizer que o objeto possuirá chaves do tipo “<i>OperationSymbols” </i>e valores do tipo<i> “CalculationsMapper”.&nbsp;</i></p><p>Entretanto, vale ressaltar que não precisaria colocar o retorno da função pois o Typescript consegue inferir isso, e na variável operations o typescript também consegue inferir o tipo dela, embora não seja o caso, eu particularmente prefiro adicionar tipos no retorno de funções, argumentos e relações contratuais (shape de objetos que transitam por camadas).</p><p>Por fim, precisamos refatorar a função “calculate” para ela utilizar essas estruturas novas:</p><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/900/1*sM4TGOKqk3WdjyWUHKkjEw.png\" alt=\"function calculate(symbol,&nbsp;…numbers) {\n&nbsp;const calculateOperation = getCalculateOperationBySymbol(symbol);\n&nbsp;console.log(‘received numbers: ‘, numbers);\n&nbsp;return calculateOperation(…numbers);\n&nbsp;}\n&nbsp;\n&nbsp;\n&nbsp;const firstResult = calculate(“+”, 2, 2);\n&nbsp;console.log(firstResult); // output: 4\n&nbsp;\n&nbsp;const secondResult = calculate(“-”, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n&nbsp;console.log(secondResult); // output: -45\"></figure><figure class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/1200/1*HrktYS4u1MMMpZxeB5Nx4g.png\" alt=\"function calculate(symbol: OperationSymbols,&nbsp;…numbers: number[]): number {\n&nbsp;const calculateOperation = getCalculateOperationBySymbol(symbol);\n&nbsp;console.log(‘received numbers: ‘, numbers);\n&nbsp;return calculateOperation(…numbers);\n&nbsp;}\n&nbsp;\n&nbsp;const firstResult = calculate(“+”, 2,2);\n&nbsp;console.log(firstResult); // output: 4\"></figure><p>Função que recebe um símbolo aritmético como primeiro argumento e a partir do segundo argumento uma quantidade indefinida de números e retorna o resultado da operação aritmética desses números referente ao símbolo e números recebidos.</p><p>Na refatoração da função calculate, fizemos com que ela deixasse de ser uma Higher-order function. Invés dela receber uma “fn” e invocar essa “fn” com os números recebidos, ela passou a receber um “symbol” e ela invoca a função “getCalculateOperationBySymbol” passando o “symbol” como argumento, assim obtendo o retorno que chamei de calculateOperation e é uma função. Após isso, ela faz um log dos números e invoca essa função com os números recebidos e retorna o resultado dessa operação.</p><p>Finalmente, com a ideia de função que retorna outra função elucidada, vamos às funções de primeira linha!</p><h3>First-Class functions</h3><p>Função de primeira ou função de primeira classe é quando uma linguagem de programação possibilita que funções possam ser tratadas como valores, ou seja como uma variável qualquer.</p>",
        "allowedComments": true,
        "cover": {
          "id": "6115260d0eec2e8db81cea43",
          "alternativeText": "",
          "url": "https://res.cloudinary.com/dtzgb4r5p/image/upload/v1628775944/hof_result_3_ts_3db08a7125.png"
        },
        "categories": [
          {
            "id": "61151d4c0e89150f688ec466",
            "name": "JavaScript",
            "slug": "java-script"
          }
        ],
        "tags": [
          {
            "id": "61151ddd0e89150f688ec46a",
            "name": "higher order functions",
            "slug": "higher-order-functions"
          }
        ],
        "author": {
          "id": "61151d220e89150f688ec465",
          "name": "João Bispo",
          "slug": "joao-bispo"
        }
      }
    ]
  }
}
